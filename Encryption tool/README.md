# Introduction

In this assignment we developped a symmetric encryption tool in C, using the OpenSSL toolkit. More specifically, we used the EVP and CMAC APIs in order to implement the AES cryptographic algorithm in ECB mode with both 128-bit and 256-bit modes.

This assignment splits into five six tasks :  

 - *Key Derivation Function (KDF)* : Derives the symmetric key based on a user's given password and a key-size desired. Key generation comes from the use of EVP_Digest function and the SHA1 cryptographic hash function.
 
 - *Task B Data Encryption* : Provides AES-ECB 128-bit / 256-bit key encryption of an input file, using  key generated by the KDF and stores the ciphertext in an output file.
 
 - *Task C Data Decryption* : Provides AES-ECB 128 / 256-bit key decryption of a ciphertext from an input file, using the same key generated by the KDF for encryption and stores the plaintext in an output file. 
 
 - *Task D Data Signing (CMAC)* : Generates a Cipher-based Message Authentication Code (CMAC). After reading the plaintext from an input file, encrypts it using the key generated by the KDF and finally, stores the ciphertext concatenated with the generated CMAC in an output file. 

 - *Task E Data Verification (CMAC)* : Provides CMAC verification. After reading from an input file the concatenated ciphertext with its CMAC, it separates them and decrypts the ciphertext. Then, it generates a CMAC for the plaintext and compares those two for the verification.
 
 -  *Task F* : Using the tool. Input file "hpy414_verifyme_256.txt" does not run at all, and I could not figure out where the problem is, so I cannot answer if the verification is or is not successful. On the other hand input file "hpy414_verifyme_128.txt"  compiles and runs successfully. The verification of  "hpy414_verifyme_128.txt" is not successful.


## How to build

**Makefile**
See *Makefile* for the build scripts.

To compile, simply run *make* at the command line in the current directory. This will generate an executable called assign_1.

If you want to remove any files that were created after *make* command, run *make clean*. 

The overall build process is controlled by the *Makefile*. It provides the following commands:
``` c
make
make encrypt
make decrypt
make sign
make verify128
make verify256
make clean
```
## Implementation
In this assignment the initialization vector IV was intentionally omitted.

**Task A**
``` c
unsigned char* keygen(unsigned char *password, int l_pass, int bit_mode)
```
Function returns a symmetric key based on a user's given password and a key-size desired.
Key generation comes from the use of EVP_Digest function and the SHA1 cryptographic hash function.

**Task B**
``` c
unsigned char*
encrypt(unsigned char *plaintext, int plaintext_len, unsigned char *key, int bit_mode)
```
In this function we use five fundamental functions for encryption from *EVP API*:

 - EVP_CIPHER_CTX_new : Create and initialise the context
 - EVP_EncryptInit_ex : Initialise the encryption operation and ensure for the appropriate key size
 - EVP_EncryptUpdate : Provide the message to be encrypted and obtain the encrypted output
 - EVP_EncryptFinal_ex : Finalise the encryption, plus further ciphertext bytes may be written
 - EVP_CIPHER_CTX_cleanup : Clean up

**Task C**
``` c
unsigned char*
decrypt(unsigned char *ciphertext, int ciphertext_len, unsigned char *key, int bit_mode)
```
In this function we use five fundamental functions for decryption from *EVP API*:

 - EVP_CIPHER_CTX_new : Create and initialise the context
 - EVP_DecryptInit_ex : Initialise the decryption operation and ensure for the appropriate key size
 - EVP_DecryptUpdate : Provide the message to be decrypted and obtain the decrypted output
 - EVP_DecryptFinal_ex : Finalise the decryption
 - EVP_CIPHER_CTX_cleanup : Clean up

**Task D**
``` c
unsigned char*
gen_cmac(unsigned char *data, size_t data_len, unsigned char *key, int bit_mode)
```
In this function we use five fundamental functions for decryption from *CMAC API*:

 - CMAC_CTX_new : Create and initialise the context
 - CMAC_Init : Initialise context for use with the given symmetric key. Calculates and internally stores the two subkeys and initializes context for subsequently feeding in data with *CMAC_Update*
 - CMAC_Update : Depending on the number of input bytes already cached in context and on the block size, this function may encrypt zero or more blocks.
 - CMAC_Final : Stores the length of the message authentication code in bytes, which equals the cipher block size, into CMAC length. Unless CMAC is `NULL`, it encrypts the last block, padding it if required, and copies the resulting message authentication code to CMAC. 
 - CMAC_CTX_free : Clean up.

**Task E**
``` c
int verify_cmac(unsigned char *cmac1, unsigned char *cmac2)
```
In this function we use *strcmp* function to compare if *cmac1* is equal to *cmac2*, so as the input file is verified successfully or not in the end.

###  Helper functions or macros
``` c
* errPrint():	Prints errors to stdout.
* #define CMAC_SIZE 16: Size of generated CMAC 
```
